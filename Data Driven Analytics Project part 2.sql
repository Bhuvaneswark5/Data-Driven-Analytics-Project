-- SQL Sprint 10, Project Part 2

use modelcarsdb;

--
-- TASK 1 : Employee Data Analysis
--

-- 1.Find the total number of employees
select count(employeenumber) as Total_no_of_Employees from employees;

-- Interpretation : There are total 23 employees 

-- 2.List all employees with their basic information
SELECT employeeNumber, lastName, firstName, email, officeCode, jobTitle
FROM employees;

-- Interpretation : Above query returns the basic information of employees

-- 3.Count the number of employees holding each job title
SELECT jobTitle, COUNT(*) AS num_employees
FROM employees
GROUP BY jobTitle;

/*interpretation : There are  President	1, VP Sales	1, VP Marketing	1,Sales Manager (APAC)	1,
Sale Manager (EMEA)	1,Sales Manager (NA)	1, Sales Rep	17 */

-- 4.Find the employees who don't have a manager (reports to is NULL)
SELECT employeeNumber, lastName, firstName, email, officeCode, jobTitle
FROM employees
WHERE reportsTo IS NULL;

-- Interpretation : 'Murphy Diane' is the 'President' ,don't have a manager

-- 5.Calculate total Sales generated by each sales representative
SELECT e.employeeNumber,
       CONCAT(e.firstName, ' ', e.lastName) AS sales_representative,
       SUM(od.quantityOrdered * od.priceEach) AS total_sales
FROM employees e
JOIN customers c ON e.employeeNumber = c.salesRepEmployeeNumber
JOIN orders o ON c.customerNumber = o.customerNumber
JOIN orderdetails od ON o.orderNumber = od.orderNumber
where jobtitle = 'sales Rep' 
GROUP BY e.employeeNumber, sales_representative
ORDER BY total_sales DESC;

-- interpretation : The total Sales generated by each sales representative is Identified

-- 6.Find the most profitable sales representative based on total sales
SELECT e.employeeNumber, 
       CONCAT(e.firstName, ' ', e.lastName) AS sales_representative,
       SUM(od.quantityOrdered * od.priceEach) AS total_sales
FROM employees e
JOIN customers c ON e.employeeNumber = c.salesRepEmployeeNumber
JOIN orders o ON c.customerNumber = o.customerNumber
JOIN orderdetails od ON o.orderNumber = od.orderNumber
where jobtitle = 'sales Rep' 
GROUP BY e.employeeNumber, sales_representative
ORDER BY total_sales DESC
LIMIT 1;

-- Interpretation : most profitable sales representative based on total sales is identified

-- 7.Find the names of all employees who have sold more than the average sales amount for their office
SELECT e.firstName, e.lastName
FROM employees e
JOIN customers c ON e.employeeNumber = c.salesRepEmployeeNumber
JOIN (
    SELECT c.salesRepEmployeeNumber, AVG(p.amount) AS avg_sales_amount
    FROM customers c
    JOIN orders o ON c.customerNumber = o.customerNumber
    JOIN payments p ON c.customerNumber = p.customerNumber
    GROUP BY c.salesRepEmployeeNumber
) AS avg_sales ON e.employeeNumber = avg_sales.salesRepEmployeeNumber
JOIN (
    SELECT c.salesRepEmployeeNumber, SUM(p.amount) AS total_sales_amount
    FROM customers c
    JOIN payments p ON c.customerNumber = p.customerNumber
    GROUP BY c.salesRepEmployeeNumber
) AS emp_sales ON e.employeeNumber = emp_sales.salesRepEmployeeNumber
WHERE emp_sales.total_sales_amount > avg_sales.avg_sales_amount;

-- interpretation : Names of all employees who have sold more than the average sales amount for their office is idendified.

-- 
-- TASK 2 : Order Analysis
-- 

-- 1.Find the average order amount for each customer
select customers.customernumber, customername, avg(amount) as avg_order_amount from customers
join payments on customers.customernumber = payments.customernumber
group by customers.customernumber;

-- interpretation : the average order amount for each customer is identified

-- 2.Find the number of orders placed in each month
select monthname(orderdate) as _Month , count(ordernumber) as no_of_orders from orders
group by _month;

/* Interpretation : Number of orders for each month is identified.maximun number of orders 
are placed in month of november and minimum orders are placed in August. */

-- 3.Identify orders that are still pending shipment(status = 'Pending')
select ordernumber , status from orders
where status IN ('On Hold','Disputed','In Process');

/* Interpretation : There are total 326 placed by different customer in that 303 orders are shipped
and 23 orders are pending. */

-- 4.List orders along with customer details
select customers.customernumber, customername, orders.orderNumber,productname from customers
join orders on customers.customernumber = orders.customerNumber
join orderdetails on orders.ordernumber = orderdetails.orderNumber
join products on orderdetails.productcode = products.productcode;

-- interpretation : List orders along with customer details are identified

-- 5.Retrieve the most recent orders (based on order date)
select orders.ordernumber, productname,orders.orderdate from orders
join orderdetails on orders.ordernumber = orderdetails.orderNumber
join products on orderdetails.productcode = products.productcode
order by  orders.orderdate desc;

-- Interpretation : Most recent orders is retrieved by sorting the orderdate descending
 
-- 6.calculate total sales for each orders
select orders.orderNumber , sum(quantityordered * priceeach) as total_sales from orders
join orderdetails on orders.ordernumber = orderdetails.orderNumber
group by orders.ordernumber;

-- interpretation : total sales for each orders is identified

-- 7.find the highest-value order based on total sales
select orders.orderNumber , sum(quantityordered * priceeach) as total_sales from orders
join orderdetails on orders.ordernumber = orderdetails.orderNumber
group by orders.ordernumber
order by total_sales desc 
limit 5 ;

-- interpretation : highest-value order based on total sales is identified

-- 8.List all orders with their corresponding order details
select orders.ordernumber,orders.orderdate,orders.status,orders.shippedDate,orderdetails.productcode,
orderdetails.quantityOrdered,orderdetails.priceeach,orderdetails.orderLineNumber from orders
join orderdetails on orders.orderNumber = orderdetails.orderNumber ;

-- interpretation : listed all orders with their corresponding order details 

-- 9.List the most frequently ordered products
SELECT p.productCode, p.productName, COUNT(*) AS total_orders
FROM orderdetails od
INNER JOIN orders o ON od.orderNumber = o.orderNumber
INNER JOIN products p ON od.productCode = p.productCode
GROUP BY p.productCode, p.productName
ORDER BY total_orders DESC
limit 20;

-- interpretation : most frequently ordered products are identified

-- 10.calculate total revenue for each order
select orders.ordernumber, sum(quantityordered * priceeach) as total_revenue from orders
join orderdetails on orders.ordernumber = orderdetails.ordernumber
group by orders.ordernumber;

-- interpratation : total revenue for each order is calculated 

-- 11.identify the most profitable orders based on total revenue
SELECT orders.orderNumber, SUM(quantityOrdered * priceEach) AS totalRevenue
FROM orders 
INNER JOIN orderdetails  ON orders.orderNumber = orderdetails.orderNumber
GROUP BY orders.orderNumber
ORDER BY totalRevenue DESC
LIMIT 10;

-- interpretation : most profitable orders based on total revenue is identified

-- 12.list all orders with detailes product information
select orders.ordernumber,orders.orderdate, orderdetails.productcode,products.productName,
orderdetails.quantityordered,orderdetails.priceEach, (quantityordered * priceEach) AS lineTotal from orders
join orderdetails on orders.ordernumber = orderdetails.orderNumber
join products on orderdetails.productcode = products.productcode;

-- interpretation : listed all orders with detailes product information
    
-- 13.identify orders with delayed shipping 
select orders.ordernumber from orders
where shippeddate > requireddate;

-- interpretation : orders with delayed shipping are identified

-- 14.find the most popular product combinations within orders
SELECT p1.productCode AS productCode1, p2.productCode AS productCode2, COUNT(*) AS orderCount
FROM orderdetails od1
INNER JOIN orders o ON od1.orderNumber = o.orderNumber
INNER JOIN orderdetails od2 ON o.orderNumber = od2.orderNumber
INNER JOIN products p1 ON od1.productCode = p1.productCode
INNER JOIN products p2 ON od2.productCode = p2.productCode
WHERE od1.productCode <> od2.productCode  -- Ensures distinct products
GROUP BY p1.productCode, p2.productCode
ORDER BY orderCount DESC
LIMIT 10;

-- interpretation : most popular product combinations within orders are identified

 -- 15.Calculate revenue for each order and identify the top 10 most profitable
SELECT orders.orderNumber, SUM(quantityOrdered * priceEach) AS totalRevenue
FROM orders 
INNER JOIN orderdetails  ON orders.orderNumber = orderdetails.orderNumber
GROUP BY orders.orderNumber
ORDER BY totalRevenue DESC
LIMIT 10;

-- Interpretation : Top 10 most profitable orders based on revenue is identified 
 
 /* 16.create a trigger that automatically updates a customer's credit limit after a
 new order is placed, reducing it by the order total */
 
DELIMITER //

CREATE TRIGGER update_credit_limit
AFTER INSERT ON orders
FOR EACH ROW
BEGIN
    DECLARE total_order_amount DECIMAL(10,2);
    
    -- Calculate the total order amount for the new order
    SELECT SUM(od.quantityOrdered * od.priceEach)
    INTO total_order_amount
    FROM orderdetails od
    WHERE od.orderNumber = NEW.orderNumber;
    
    -- Update the customer's credit limit
    UPDATE customers
    SET creditLimit = creditLimit - total_order_amount
    WHERE customerNumber = NEW.customerNumber;
END //

DELIMITER ;

-- interpretation : Trigger is created 

 /* 17.create a trigger that logs product quantity changes whenever an order details
 is inserted or updated */
 
DELIMITER //

CREATE TRIGGER log_product_quantity_changes
AFTER INSERT  ON orderdetails
FOR EACH ROW
BEGIN
    DECLARE action VARCHAR(10);
    DECLARE log_message VARCHAR(255);

    -- Determine the action (INSERT or UPDATE)
    IF INSERTING THEN
        SET action = 'INSERT';
    ELSE
        SET action = 'UPDATE';
    END IF;

    -- Prepare log message
    SET log_message = CONCAT(action, ' - Order Number: ', NEW.orderNumber,
                             ', Product Code: ', NEW.productCode,
                             ', Quantity: ', NEW.quantityOrdered);

    -- Insert log entry into a temporary log table
    CREATE TEMPORARY TABLE IF NOT EXISTS temp_product_quantity_logs (
        log_id INT AUTO_INCREMENT PRIMARY KEY,
        log_message VARCHAR(255),
        log_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );

    INSERT INTO temp_product_quantity_logs (log_message)
    VALUES (log_message);
END //

DELIMITER ;

-- interpretation : Trigger created successfully

 -- Sprint 10, Project Part 2 completed
 
 
 
